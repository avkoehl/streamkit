{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"streamkit","text":"<p>A python toolkit for terrain-based stream network processing.</p>"},{"location":"#overview","title":"Overview","text":"<p>streamkit provides tools for analyzing and manipulating stream networks derived from DEMs. It repackages and extends functionality from several great libraries (pysheds, hyriver, whitebox, etc.) to be more convenient to use in my workflows that use rioxarray to represent raster data.</p>"},{"location":"align_nhd/","title":"Aligning NHD Data to DEM","text":"In\u00a0[2]: Copied! <pre>import rioxarray as rxr\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\nfrom streamkit import rasterize_nhd\n</pre> import rioxarray as rxr import geopandas as gpd import matplotlib.pyplot as plt  from streamkit import rasterize_nhd In\u00a0[4]: Copied! <pre>flowlines = gpd.read_file(\"data/sample_nhd.gpkg\")\ndem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze()\n</pre> flowlines = gpd.read_file(\"data/sample_nhd.gpkg\") dem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze() In\u00a0[5]: Copied! <pre>aligned = rasterize_nhd(flowlines, dem)\n</pre> aligned = rasterize_nhd(flowlines, dem) In\u00a0[6]: Copied! <pre>aligned.plot()\n</pre> aligned.plot() Out[6]: <pre>&lt;matplotlib.collections.QuadMesh at 0x15453dca0&gt;</pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#watershed-analysis","title":"Watershed Analysis","text":""},{"location":"api/#streamkit.watershed.compute_hand","title":"<code>streamkit.watershed.compute_hand(dem, flow_directions, streams)</code>","text":"Source code in <code>streamkit/watershed.py</code> <pre><code>def compute_hand(dem, flow_directions, streams):\n    # note ESRI d8 flow direction encoding\n    dem, grid = to_pysheds(dem)\n    flow_directions, _ = to_pysheds(flow_directions)\n    streams, _ = to_pysheds(streams)\n    dirmap = (64, 128, 1, 2, 32, 16, 8, 4)\n    hand = grid.compute_hand(flow_directions, dem, streams &gt; 0, dirmap=dirmap)\n    return from_pysheds(hand)\n</code></pre>"},{"location":"api/#streamkit.watershed.flow_accumulation_workflow","title":"<code>streamkit.watershed.flow_accumulation_workflow(dem)</code>","text":"<p>Given a DEM, compute the conditioned DEM, flow directions, and flow accumulation. Uses d8 flow directions, wraps around whiteboxtools 'fill depression with fix flats' algorithm. Flow direction and accumulation done with pysheds. Uses ESRI flow direction encoding.</p> <p>Parameters:</p> Name Type Description Default <code>dem</code> <code>DataArray</code> <p>DEM raster</p> required <p>Returns:     (conditioned DEM, flow directions, and flow accumulation)</p> Source code in <code>streamkit/watershed.py</code> <pre><code>def flow_accumulation_workflow(\n    dem: xr.DataArray,\n) -&gt; tuple[xr.DataArray, xr.DataArray, xr.DataArray]:\n    \"\"\"\n    Given a DEM, compute the conditioned DEM, flow directions, and flow\n    accumulation. Uses d8 flow directions, wraps around whiteboxtools 'fill\n    depression with fix flats' algorithm. Flow direction and accumulation done\n    with pysheds. Uses ESRI flow direction encoding.\n\n    Args:\n        dem: DEM raster\n    Returns:\n        (conditioned DEM, flow directions, and flow accumulation)\n\n    \"\"\"\n    # wbt condition\n    conditioned_dem = condition_dem(dem)\n    pysheds_conditioned_dem, grid = to_pysheds(conditioned_dem)\n    flow_directions = grid.flowdir(pysheds_conditioned_dem)\n    flow_accumulation = grid.accumulation(flow_directions)\n    return (\n        from_pysheds(pysheds_conditioned_dem),\n        from_pysheds(flow_directions),\n        from_pysheds(flow_accumulation),\n    )\n</code></pre>"},{"location":"api/#streamkit.watershed.delineate_subbasins","title":"<code>streamkit.watershed.delineate_subbasins(stream_raster, flow_directions, flow_accumulation)</code>","text":"<p>Delineate all subbasins given a channel network raster. Detects pour points for each unique stream segment by finding the cell with the highest flow accumulation for that segment (based on ID).</p> <p>Parameters:</p> Name Type Description Default <code>stream_raster</code> <code>DataArray</code> <p>Raster of channel network with unique IDs for each segment</p> required <code>flow_directions</code> <code>DataArray</code> <p>Flow directions raster (ESRI d8 encoding)</p> required <code>flow_accumulation</code> <code>DataArray</code> <p>Flow accumulation raster</p> required <p>Returns:     Raster of subbasins with same IDs as stream_raster</p> Source code in <code>streamkit/watershed.py</code> <pre><code>def delineate_subbasins(\n    stream_raster: xr.DataArray,\n    flow_directions: xr.DataArray,\n    flow_accumulation: xr.DataArray,\n) -&gt; xr.DataArray:\n    \"\"\"\n    Delineate all subbasins given a channel network raster. Detects pour points\n    for each unique stream segment by finding the cell with the highest flow\n    accumulation for that segment (based on ID).\n\n    Args:\n        stream_raster: Raster of channel network with unique IDs for each\n            segment\n        flow_directions: Flow directions raster (ESRI d8 encoding)\n        flow_accumulation: Flow accumulation raster\n    Returns:\n        Raster of subbasins with same IDs as stream_raster\n    \"\"\"\n    # get pour points from channel network raster\n    # these are sorted so that nested basins are handled correctly\n    pour_points = _identify_pour_points(stream_raster, flow_accumulation)\n\n    subbasins = stream_raster.copy(\n        data=np.zeros_like(stream_raster.data, dtype=np.int32)\n    )\n\n    pysheds_fdir, grid = to_pysheds(flow_directions)\n\n    for _, row in pour_points.iterrows():\n        pour_row = row[\"row\"]\n        pour_col = row[\"col\"]\n\n        catchment = grid.catchment(\n            x=pour_col,\n            y=pour_row,\n            fdir=pysheds_fdir,\n            xytype=\"index\",\n        )\n\n        subbasins.data[catchment] = row[\"stream_value\"]\n\n    return subbasins\n</code></pre>"},{"location":"api/#stream-vectorization-and-network-conversion","title":"Stream Vectorization and Network Conversion","text":""},{"location":"api/#streamkit.vectorize_streams.vectorize_streams","title":"<code>streamkit.vectorize_streams.vectorize_streams(stream_raster, flow_directions, flow_accumulation)</code>","text":"<p>Vectorize streams from a raster to a GeoDataFrame of LineStrings. Args:     stream_raster: A raster of stream segments with unique IDs.     flow_directions: A raster of flow directions (ESRI D8 encoding).     flow_accumulation: A raster of flow accumulation values. Returns:     A GeoDataFrame with LineString geometries representing the streams with stream_id column (from the raster values).</p> Source code in <code>streamkit/vectorize_streams.py</code> <pre><code>def vectorize_streams(\n    stream_raster: xr.DataArray,\n    flow_directions: xr.DataArray,\n    flow_accumulation: xr.DataArray,\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Vectorize streams from a raster to a GeoDataFrame of LineStrings.\n    Args:\n        stream_raster: A raster of stream segments with unique IDs.\n        flow_directions: A raster of flow directions (ESRI D8 encoding).\n        flow_accumulation: A raster of flow accumulation values.\n    Returns:\n        A GeoDataFrame with LineString geometries representing the streams with stream_id column (from the raster values).\n    \"\"\"\n    flowlines = []\n    for stream_id in np.unique(stream_raster.values):\n        if stream_id == 0 or np.isnan(stream_id):\n            continue\n\n        stream_mask = stream_raster == stream_id\n        flow_acc = flow_accumulation * stream_mask.data\n        flow_dir = flow_directions * stream_mask.data\n\n        # skip any empty streams or those with one cell\n        if np.sum(stream_mask) &lt; 2:\n            continue\n\n        line = _vectorize_single_stream(stream_mask, flow_dir, flow_acc)\n        flowlines.append({\"geometry\": line, \"stream_id\": int(stream_id)})\n\n    gdf = gpd.GeoDataFrame(flowlines, crs=stream_raster.rio.crs)\n    return gdf\n</code></pre>"},{"location":"api/#streamkit.nx_convert.vector_streams_to_networkx","title":"<code>streamkit.nx_convert.vector_streams_to_networkx(lines)</code>","text":"<p>Convert a GeoDataFrame of LineString geometries to a NetworkX directed graph.</p> <p>Creates a directed graph where nodes represent stream endpoints (start and end coordinates) and edges represent stream segments. All attributes from the input GeoDataFrame are preserved as edge attributes in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing LineString geometries representing stream segments, along with any associated attributes.</p> required <p>Returns:</p> Type Description <code>DiGraph</code> <p>A directed graph where edges contain the original geometry, CRS, and all other attributes from the input GeoDataFrame.</p> Source code in <code>streamkit/nx_convert.py</code> <pre><code>def vector_streams_to_networkx(lines: gpd.GeoDataFrame) -&gt; nx.DiGraph:\n    \"\"\"Convert a GeoDataFrame of LineString geometries to a NetworkX directed graph.\n\n    Creates a directed graph where nodes represent stream endpoints (start and end\n    coordinates) and edges represent stream segments. All attributes from the input\n    GeoDataFrame are preserved as edge attributes in the graph.\n\n    Args:\n        lines: GeoDataFrame containing LineString geometries representing stream\n            segments, along with any associated attributes.\n\n    Returns:\n        A directed graph where edges contain the original geometry, CRS, and all other attributes from the input GeoDataFrame.\n    \"\"\"\n    G = nx.DiGraph()\n    for _, line in lines.iterrows():\n        start = line.geometry.coords[0]\n        end = line.geometry.coords[-1]\n        G.add_edge(\n            start,\n            end,\n            crs=lines.crs,\n            geometry=line.geometry,\n            **line.drop(\"geometry\").to_dict(),\n        )\n    return G\n</code></pre>"},{"location":"api/#streamkit.nx_convert.networkx_to_gdf","title":"<code>streamkit.nx_convert.networkx_to_gdf(G)</code>","text":"<p>Convert a NetworkX directed graph back to a GeoDataFrame.</p> <p>Reconstructs vector stream data from a graph representation by converting each edge into a LineString geometry connecting its start and end nodes. All edge attributes are preserved in the output GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>DiGraph</code> <p>A directed graph representing stream networks. Edges must contain 'crs' and 'geometry' attributes, typically created by vector_streams_to_networkx().</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with LineString geometries representing stream segments and all edge attributes from the graph (excluding the 'crs' attribute which is set as the GeoDataFrame's CRS).</p> Source code in <code>streamkit/nx_convert.py</code> <pre><code>def networkx_to_gdf(G: nx.DiGraph) -&gt; gpd.GeoDataFrame:\n    \"\"\"Convert a NetworkX directed graph back to a GeoDataFrame.\n\n    Reconstructs vector stream data from a graph representation by converting\n    each edge into a LineString geometry connecting its start and end nodes.\n    All edge attributes are preserved in the output GeoDataFrame.\n\n    Args:\n        G: A directed graph representing stream networks. Edges must contain\n            'crs' and 'geometry' attributes, typically created by\n            vector_streams_to_networkx().\n\n    Returns:\n        A GeoDataFrame with LineString geometries representing stream segments and all edge attributes from the graph (excluding the 'crs' attribute which is set as the GeoDataFrame's CRS).\n    \"\"\"\n    edges = []\n    for u, v, data in G.edges(data=True):\n        edges.append(\n            {\n                \"geometry\": gpd.points_from_xy([u[0], v[0]], [u[1], v[1]]).unary_union,\n                **data,\n            }\n        )\n    gdf = gpd.GeoDataFrame(edges, geometry=\"geometry\")\n    gdf = gdf.set_crs(gdf[\"crs\"].iloc[0])\n    gdf = gdf.drop(columns=[\"crs\"])\n    return gdf\n</code></pre>"},{"location":"api/#network-analysis","title":"Network Analysis","text":""},{"location":"api/#streamkit.strahler.strahler_order","title":"<code>streamkit.strahler.strahler_order(G)</code>","text":"<p>Calculate the Strahler order for each edge in a directed graph.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>DiGraph</code> <p>A directed graph representing a river network. Use 'vector_streams_to_networkx()' to create this from vector data.</p> required <p>Returns:     The same directed graph with an additional 'strahler' attribute on each edge indicating its Strahler order.</p> Source code in <code>streamkit/strahler.py</code> <pre><code>def strahler_order(G: nx.DiGraph) -&gt; nx.DiGraph:\n    \"\"\"Calculate the Strahler order for each edge in a directed graph.\n\n    Args:\n        G: A directed graph representing a river network. Use 'vector_streams_to_networkx()' to create this from vector data.\n    Returns:\n        The same directed graph with an additional 'strahler' attribute on each edge indicating its Strahler order.\n    \"\"\"\n    # first, find all root nodes\n    # then, for each subgraph, find the strahler order of each edge\n    G = G.copy()\n    roots = [n for n in G.nodes if G.out_degree(n) == 0]\n    for root in roots:\n        _calculate_strahler(G, root)\n    return G\n</code></pre>"},{"location":"api/#streamkit.upstream_length.upstream_length","title":"<code>streamkit.upstream_length.upstream_length(G)</code>","text":"<p>Compute the maximum upstream length for each edge in a directed graph G. Uses the length attribute of the edge geometry.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>DiGraph</code> <p>A directed graph where edges have a 'geometry' attribute (shapely LineString).</p> required <p>Returns:     A copy of the graph with an additional attribute 'max_upstream_length' for each edge.</p> Source code in <code>streamkit/upstream_length.py</code> <pre><code>def upstream_length(G: nx.DiGraph) -&gt; nx.DiGraph:\n    \"\"\"\n    Compute the maximum upstream length for each edge in a directed graph G. Uses the length attribute of the edge geometry.\n\n    Args:\n        G: A directed graph where edges have a 'geometry' attribute (shapely LineString).\n    Returns:\n        A copy of the graph with an additional attribute 'max_upstream_length' for each edge.\n    \"\"\"\n    # Compute the maximum upstream length for each edge in a directed graph G.\n    # confirm that all edges have a 'geometry' attribute\n    G = G.copy()\n    if not all(\"geometry\" in G.edges[e] for e in G.edges):\n        raise ValueError(\n            \"All edges must have a 'geometry' attribute. Cannot compute upstream length.\"\n        )\n\n    for u, v, d in G.edges(data=True):\n        d[\"max_upstream_length\"] = 0.0\n\n    for node in nx.topological_sort(G):\n        upstream = list(G.in_edges(node, data=True))\n\n        if len(upstream) == 0:\n            # this is headwater, set length to the length of the edge.geometry\n            out_edges = list(G.out_edges(node, data=True))\n            if len(out_edges) == 1:\n                _, _, out_data = out_edges[0]\n                length = out_data.get(\"geometry\").length\n        elif len(upstream) == 1:\n            u, v, data = upstream[0]\n            length = data.get(\"max_upstream_length\") + data.get(\"geometry\").length\n        else:\n            max_upstream_length = 0.0\n            for u, v, data in upstream:\n                upstream_length = (\n                    data.get(\"max_upstream_length\") + data.get(\"geometry\").length\n                )\n                if upstream_length &gt; max_upstream_length:\n                    max_upstream_length = upstream_length\n            length = max_upstream_length\n\n        for _, v, out_data in G.out_edges(node, data=True):\n            out_data[\"max_upstream_length\"] = length\n    return G\n</code></pre>"},{"location":"api/#streamkit.mainstem.label_mainstem","title":"<code>streamkit.mainstem.label_mainstem(G)</code>","text":"<p>Label mainstem edges in a stream network graph.</p> <p>Identifies and labels the main channel (mainstem) of each drainage network by traversing from outlet nodes upstream. Edges are labeled with a 'mainstem' attribute set to True for mainstem edges and False for tributaries.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>DiGraph</code> <p>A directed graph representing a stream network. Each edge must have 'strahler' and 'max_upstream_length' attributes. If these are missing, run strahler_order() and upstream_length() first.</p> required <p>Returns:</p> Type Description <code>DiGraph</code> <p>A copy of the input graph with edges labeled with a 'mainstem' boolean attribute indicating whether each edge is part of the main channel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any edge is missing the required 'strahler' or 'max_upstream_length' attributes.</p> Source code in <code>streamkit/mainstem.py</code> <pre><code>def label_mainstem(G: nx.DiGraph) -&gt; nx.DiGraph:\n    \"\"\"Label mainstem edges in a stream network graph.\n\n    Identifies and labels the main channel (mainstem) of each drainage network\n    by traversing from outlet nodes upstream. Edges are labeled with a 'mainstem'\n    attribute set to True for mainstem edges and False for tributaries.\n\n    Args:\n        G: A directed graph representing a stream network. Each edge must have\n            'strahler' and 'max_upstream_length' attributes. If these are missing,\n            run strahler_order() and upstream_length() first.\n\n    Returns:\n        A copy of the input graph with edges labeled with a 'mainstem' boolean attribute indicating whether each edge is part of the main channel.\n\n    Raises:\n        ValueError: If any edge is missing the required 'strahler' or\n            'max_upstream_length' attributes.\n    \"\"\"\n    G = G.copy()\n\n    # make sure that edges have a 'strahler' attribute\n    if not all(\"strahler\" in G.edges[e] for e in G.edges):\n        raise ValueError(\n            \"All edges must have a 'strahler' attribute. Run strahler_order() first.\"\n        )\n    if not all(\"max_upstream_length\" in G.edges[e] for e in G.edges):\n        raise ValueError(\n            \"All edges must have a 'max_upstream_length' attribute. Run upstream_length() first.\"\n        )\n\n    # initialize all edges as not mainstem_edge\n    for e in G.edges:\n        G.edges[e][\"mainstem\"] = False\n\n    roots = [n for n in G.nodes if G.out_degree(n) == 0]\n    for root in roots:\n        _label_mainstem(G, root)\n    return G\n</code></pre>"},{"location":"api/#streamkit.xs.network_cross_sections","title":"<code>streamkit.xs.network_cross_sections(linestrings, interval_distance, width, linestring_ids=None, smoothed=False)</code>","text":"<p>Create cross-sections at regular intervals along linestrings.</p> <p>Parameters:</p> Name Type Description Default <code>linestrings</code> <code>GeoSeries</code> <p>Linestring geometries.</p> required <code>interval_distance</code> <code>float</code> <p>Distance between cross-sections along the linestrings.</p> required <code>width</code> <code>float</code> <p>Width of each cross-section.</p> required <code>linestring_ids</code> <code>Optional[Sequence]</code> <p>Optional identifiers for each linestring. If None, the index of linestrings is used.</p> <code>None</code> <code>smoothed</code> <code>bool</code> <p>Whether to use smoothed angles for cross-sections.</p> <code>False</code> <p>Returns:     cross section linestrings</p> Source code in <code>streamkit/xs.py</code> <pre><code>def network_cross_sections(\n    linestrings: gpd.GeoSeries,\n    interval_distance: float,\n    width: float,\n    linestring_ids: Optional[Sequence] = None,\n    smoothed: bool = False,\n):\n    \"\"\"\n    Create cross-sections at regular intervals along linestrings.\n\n    Args:\n        linestrings: Linestring geometries.\n        interval_distance: Distance between cross-sections along the linestrings.\n        width: Width of each cross-section.\n        linestring_ids: Optional identifiers for each linestring. If None, the index of linestrings is used.\n        smoothed: Whether to use smoothed angles for cross-sections.\n    Returns:\n        cross section linestrings\n    \"\"\"\n    if linestring_ids is None:\n        linestring_ids = linestrings.index\n    else:\n        if len(linestring_ids) != len(linestrings):\n            raise ValueError(\"provided ids must match the length of linestrings\")\n\n    xsections = []\n    for cid, linestring in zip(linestring_ids, linestrings):\n        channel_xsections = _create_cross_sections(\n            linestring, interval_distance, width, crs=linestrings.crs, smoothed=smoothed\n        )\n        # convert to DataFrame and add segment_id\n        channel_xsections = gpd.GeoDataFrame(\n            geometry=channel_xsections, crs=linestrings.crs\n        )\n        channel_xsections[\"linestring_id\"] = cid\n        xsections.append(channel_xsections)\n    xsections = pd.concat(xsections)\n    xsections[\"xs_id\"] = np.arange(1, len(xsections) + 1)\n    return xsections\n</code></pre>"},{"location":"api/#streamkit.profile.sample_cross_sections","title":"<code>streamkit.profile.sample_cross_sections(xs_linestrings, point_interval)</code>","text":"<p>Generate profile points along cross-section linestrings at regular intervals.</p> <p>Creates evenly-spaced points along each cross-section line, measuring distances from the center point. Points are labeled as 'center', 'positive' (downstream of center), or 'negative' (upstream of center).</p> <p>Parameters:</p> Name Type Description Default <code>xs_linestrings</code> <code>GeoDataFrame</code> <p>GeoDataFrame containing LineString geometries representing cross-sections. If 'xs_id' column is not present, sequential IDs will be automatically assigned.</p> required <code>point_interval</code> <code>float</code> <p>Spacing between points along each cross-section, in the units of the GeoDataFrame's CRS.</p> required <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>A GeoDataFrame with Point geometries containing columns: - xs_id: Cross-section identifier - side: Position relative to center ('center', 'positive', 'negative') - distance: Distance from center point (negative for upstream, positive   for downstream) - geometry: Point geometry - Additional columns from input xs_linestrings are preserved</p> Source code in <code>streamkit/profile.py</code> <pre><code>def sample_cross_sections(\n    xs_linestrings: gpd.GeoDataFrame, point_interval: float\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"Generate profile points along cross-section linestrings at regular intervals.\n\n    Creates evenly-spaced points along each cross-section line, measuring distances\n    from the center point. Points are labeled as 'center', 'positive' (downstream\n    of center), or 'negative' (upstream of center).\n\n    Args:\n        xs_linestrings: GeoDataFrame containing LineString geometries representing\n            cross-sections. If 'xs_id' column is not present, sequential IDs will\n            be automatically assigned.\n        point_interval: Spacing between points along each cross-section, in the\n            units of the GeoDataFrame's CRS.\n\n    Returns:\n        A GeoDataFrame with Point geometries containing columns:\n            - xs_id: Cross-section identifier\n            - side: Position relative to center ('center', 'positive', 'negative')\n            - distance: Distance from center point (negative for upstream, positive\n              for downstream)\n            - geometry: Point geometry\n            - Additional columns from input xs_linestrings are preserved\n    \"\"\"\n\n    if \"xs_id\" not in xs_linestrings.columns:\n        xs_linestrings[\"xs_id\"] = np.arange(1, len(xs_linestrings) + 1)\n\n    xs_points = []\n    for xs_id, xs_linestring in xs_linestrings.groupby(\"xs_id\"):\n        for _, linestring in xs_linestring.iterrows():\n            points = _points_along_linestring(\n                linestring.geometry, point_interval, crs=xs_linestrings.crs\n            )\n            points[\"xs_id\"] = xs_id\n            # add other columns from xs_linestrings\n            for col in xs_linestring.columns:\n                if col != \"geometry\":\n                    points[col] = linestring[col]\n            xs_points.append(points)\n\n    return gpd.GeoDataFrame(\n        pd.concat(xs_points), crs=xs_linestrings.crs, geometry=\"geometry\"\n    ).reset_index(drop=True)\n</code></pre>"},{"location":"api/#terrain-analysis","title":"Terrain Analysis","text":""},{"location":"api/#streamkit.smooth.gaussian_smooth_raster","title":"<code>streamkit.smooth.gaussian_smooth_raster(raster, spatial_radius, sigma)</code>","text":"<p>Apply Gaussian smoothing to a raster while preserving NaN values.</p> <p>Performs NaN-aware Gaussian filtering that conserves intensity by only redistributing values between non-NaN pixels. NaN pixels remain NaN in the output.</p> <p>Parameters:</p> Name Type Description Default <code>raster</code> <code>DataArray</code> <p>Input raster to smooth.</p> required <code>spatial_radius</code> <code>float</code> <p>Radius of the Gaussian kernel in map units (e.g., meters). Converted internally to pixels based on raster resolution.</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of the Gaussian kernel in pixels. Controls the strength of smoothing.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Smoothed raster with the same dimensions, coordinates, and NaN pattern as the input.</p> Source code in <code>streamkit/smooth.py</code> <pre><code>def gaussian_smooth_raster(\n    raster: xr.DataArray, spatial_radius: float, sigma: float\n) -&gt; xr.DataArray:\n    \"\"\"Apply Gaussian smoothing to a raster while preserving NaN values.\n\n    Performs NaN-aware Gaussian filtering that conserves intensity by only\n    redistributing values between non-NaN pixels. NaN pixels remain NaN in\n    the output.\n\n    Args:\n        raster: Input raster to smooth.\n        spatial_radius: Radius of the Gaussian kernel in map units (e.g., meters).\n            Converted internally to pixels based on raster resolution.\n        sigma: Standard deviation of the Gaussian kernel in pixels. Controls\n            the strength of smoothing.\n\n    Returns:\n        Smoothed raster with the same dimensions, coordinates, and NaN pattern as the input.\n    \"\"\"\n    resolution = raster.rio.resolution()[0]\n    radius_pixels = int(round(spatial_radius / resolution))\n\n    raster_copy = raster.copy(deep=True)\n    raster_copy.data = _filter_nan_gaussian_conserving(\n        raster_copy.data, radius_pixels, sigma\n    )\n    return raster_copy\n</code></pre>"},{"location":"api/#streamkit.upstream_length.upstream_length_raster","title":"<code>streamkit.upstream_length.upstream_length_raster(streams, flow_direction)</code>","text":"<p>For each cell in the stream raster, compute the maximum upstream length</p> <p>Parameters:</p> Name Type Description Default <code>streams</code> <code>DataArray</code> <p>A binary raster where stream cells are 1 and non-stream cells are 0.</p> required <code>flow_direction</code> <code>DataArray</code> <p>A raster representing flow direction using ESRI convention.</p> required <p>Returns:     A raster where each stream cell contains the maximum upstream length in map units.</p> Source code in <code>streamkit/upstream_length.py</code> <pre><code>def upstream_length_raster(\n    streams: xr.DataArray, flow_direction: xr.DataArray\n) -&gt; xr.DataArray:\n    \"\"\"\n    For each cell in the stream raster, compute the maximum upstream length\n\n    Args:\n        streams: A binary raster where stream cells are 1 and non-stream cells are 0.\n        flow_direction: A raster representing flow direction using ESRI convention.\n    Returns:\n        A raster where each stream cell contains the maximum upstream length in map units.\n    \"\"\"\n    dirmap = _make_numba_esri_dirmap()\n    sources, _, _ = find_stream_nodes(streams, flow_direction)\n    distance_arr = _distance_from_head(\n        streams.data, sources, flow_direction.data, dirmap\n    )\n    distance_raster = flow_direction.copy(data=distance_arr)\n    distance_raster *= np.abs(flow_direction.rio.resolution()[0])\n    return distance_raster\n</code></pre>"},{"location":"api/#reach-delineation","title":"Reach Delineation","text":""},{"location":"api/#streamkit.reach.delineate_reaches","title":"<code>streamkit.reach.delineate_reaches(stream_raster, dem, penalty=None, min_length=500, smooth_window=None, threshold_degrees=1.0)</code>","text":"<p>Segment stream networks into reaches based on slope change points.</p> <p>Uses the PELT (Pruned Exact Linear Time) changepoint detection algorithm to identify distinct reaches along each stream based on slope variations. Adjacent reaches with similar slopes can be merged using the threshold parameter.</p> <p>Parameters:</p> Name Type Description Default <code>stream_raster</code> <code>DataArray</code> <p>Labeled stream network where each unique value represents a stream segment (0 for non-stream pixels).</p> required <code>dem</code> <code>DataArray</code> <p>Digital elevation model for slope calculations.</p> required <code>penalty</code> <code>float | None</code> <p>PELT algorithm penalty parameter. If None, automatically calculated as log(n) * variance of slope signal.</p> <code>None</code> <code>min_length</code> <code>float</code> <p>Minimum reach length in meters.</p> <code>500</code> <code>smooth_window</code> <code>int | None</code> <p>Window size for smoothing slope values before segmentation. If None, no smoothing is applied.</p> <code>None</code> <code>threshold_degrees</code> <code>float</code> <p>Merge adjacent reaches if slope difference is below this threshold in degrees.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>A raster where each pixel value represents a unique reach ID (0 for non-stream pixels). Reach IDs are computed as reach_number + stream_id * 1000.</p> Source code in <code>streamkit/reach.py</code> <pre><code>def delineate_reaches(\n    stream_raster: xr.DataArray,\n    dem: xr.DataArray,\n    penalty: float | None = None,\n    min_length: float = 500,\n    smooth_window: int | None = None,\n    threshold_degrees: float = 1.0,\n) -&gt; xr.DataArray:\n    \"\"\"Segment stream networks into reaches based on slope change points.\n\n    Uses the PELT (Pruned Exact Linear Time) changepoint detection algorithm\n    to identify distinct reaches along each stream based on slope variations.\n    Adjacent reaches with similar slopes can be merged using the threshold parameter.\n\n    Args:\n        stream_raster: Labeled stream network where each unique value represents\n            a stream segment (0 for non-stream pixels).\n        dem: Digital elevation model for slope calculations.\n        penalty: PELT algorithm penalty parameter. If None, automatically calculated\n            as log(n) * variance of slope signal.\n        min_length: Minimum reach length in meters.\n        smooth_window: Window size for smoothing slope values before segmentation.\n            If None, no smoothing is applied.\n        threshold_degrees: Merge adjacent reaches if slope difference is below this\n            threshold in degrees.\n\n    Returns:\n        A raster where each pixel value represents a unique reach ID (0 for non-stream pixels). Reach IDs are computed as reach_number + stream_id * 1000.\n    \"\"\"\n\n    _, flow_dir, flow_acc = flow_accumulation_workflow(dem)\n\n    reaches = stream_raster.copy(data=np.zeros_like(stream_raster, dtype=np.uint32))\n    for stream_val in np.unique(stream_raster):\n        if stream_val == 0 or np.isnan(stream_val):\n            continue\n        else:\n            stream_df = _create_stream_points(\n                stream_raster == stream_val, flow_dir, flow_acc, dem\n            )\n            # roughly convert min_length in meters to number of points\n            min_size = int(min_length / flow_dir.rio.resolution()[0])\n            stream_df = _pelt_reaches(\n                stream_df,\n                penalty=penalty,\n                min_size=min_size,\n                smooth_window=smooth_window,\n            )\n            stream_df = _merge_reaches_by_threshold(\n                stream_df, threshold_degrees=threshold_degrees\n            )\n            stream_df[\"reach_val\"] = stream_df[\"reach_id\"] + stream_val * 1000\n            rows, cols = stream_df[\"row\"].values, stream_df[\"col\"].values\n            reaches.data[rows, cols] = stream_df[\"reach_val\"].values\n    return reaches\n</code></pre>"},{"location":"api/#data-download-utilities","title":"Data Download Utilities","text":""},{"location":"api/#streamkit.data.get_huc_data","title":"<code>streamkit.data.get_huc_data(hucid, nhd_layer='flowline_mr', crs='EPSG:4326', dem_resolution=10, wbd=None, nhd=None)</code>","text":"<p>Download hydrological and topographic data for a given HUC ID.</p> <p>Retrieves NHD flowlines, and digital elevation model (DEM) data for the specified Hydrologic Unit Code (HUC) area.</p> <p>Parameters:</p> Name Type Description Default <code>hucid</code> <code>str</code> <p>The Hydrologic Unit Code identifier for the watershed area.</p> required <code>nhd_layer</code> <code>str</code> <p>The National Hydrography Dataset layer name for flowlines. Defaults to \"flowline_mr\" (medium resolution).</p> <code>'flowline_mr'</code> <code>crs</code> <code>str</code> <p>The coordinate reference system for the output data as an EPSG code or other CRS string. Defaults to \"EPSG:4326\" (WGS84).</p> <code>'EPSG:4326'</code> <code>dem_resolution</code> <code>int</code> <p>The spatial resolution of the DEM in meters. Defaults to 10.</p> <code>10</code> <code>wbd</code> <code>Optional[WBD]</code> <p>An existing Watershed Boundary Dataset object. If None, a new WBD instance will be created.</p> <code>None</code> <code>nhd</code> <code>Optional[NHD]</code> <p>An existing National Hydrography Dataset object. If None, a new NHD instance will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>flowlines gdf, dem raster</code> Source code in <code>streamkit/data.py</code> <pre><code>def get_huc_data(\n    hucid: str,\n    nhd_layer: str = \"flowline_mr\",\n    crs: str = \"EPSG:4326\",\n    dem_resolution: int = 10,\n    wbd: Optional[WBD] = None,\n    nhd: Optional[NHD] = None,\n) -&gt; Tuple[gpd.GeoDataFrame, xr.DataArray]:\n    \"\"\"Download hydrological and topographic data for a given HUC ID.\n\n    Retrieves NHD flowlines, and digital elevation model (DEM) data for the\n    specified Hydrologic Unit Code (HUC) area.\n\n    Args:\n        hucid: The Hydrologic Unit Code identifier for the watershed area.\n        nhd_layer: The National Hydrography Dataset layer name for flowlines.\n            Defaults to \"flowline_mr\" (medium resolution).\n        crs: The coordinate reference system for the output data as an EPSG code\n            or other CRS string. Defaults to \"EPSG:4326\" (WGS84).\n        dem_resolution: The spatial resolution of the DEM in meters. Defaults to 10.\n        wbd: An existing Watershed Boundary Dataset object. If None, a new WBD\n            instance will be created.\n        nhd: An existing National Hydrography Dataset object. If None, a new NHD\n            instance will be created.\n\n    Returns:\n        (flowlines gdf, dem raster):\n    \"\"\"\n\n    huc_bounds = download_huc_bounds(hucid, wbd)\n    flowlines = download_flowlines(huc_bounds, nhd, nhd_layer, True, crs)\n    dem = download_dem(huc_bounds, dem_resolution, crs)\n\n    return flowlines, dem\n</code></pre>"},{"location":"api/#streamkit.data.download_huc_bounds","title":"<code>streamkit.data.download_huc_bounds(huc, wbd=None)</code>","text":"Source code in <code>streamkit/data.py</code> <pre><code>def download_huc_bounds(huc, wbd=None):\n    huc = str(huc)\n    level = f\"huc{str(len(huc))}\"\n\n    if wbd is None:\n        wbd = WBD(level)\n\n    huc_wbd = wbd.byids(level, huc)\n    return huc_wbd\n</code></pre>"},{"location":"api/#streamkit.data.download_flowlines","title":"<code>streamkit.data.download_flowlines(gdf, nhd=None, layer='flowline_mr', linestring_only=True, crs='EPSG:4326')</code>","text":"Source code in <code>streamkit/data.py</code> <pre><code>def download_flowlines(\n    gdf, nhd=None, layer=\"flowline_mr\", linestring_only=True, crs=\"EPSG:4326\"\n):\n    if nhd is None:\n        nhd = NHD(layer)\n\n    boundary = gdf.union_all()\n    flowlines = nhd.bygeom(boundary)\n    flowlines = flowlines.clip(boundary)\n    flowlines = flowlines.explode()\n\n    if linestring_only:\n        flowlines = flowlines[flowlines.geometry.type == \"LineString\"]\n\n    flowlines = flowlines.to_crs(crs)\n    return flowlines\n</code></pre>"},{"location":"api/#streamkit.data.download_dem","title":"<code>streamkit.data.download_dem(gdf, resolution, crs='EPSG:4326')</code>","text":"Source code in <code>streamkit/data.py</code> <pre><code>def download_dem(gdf, resolution, crs=\"EPSG:4326\"):\n    boundary = gdf.union_all()\n    try:\n        dem = py3dep.static_3dep_dem(boundary, resolution=resolution, crs=gdf.crs)\n    except:\n        dem = retry_on_smaller(boundary)\n\n    if dem.rio.crs != crs:\n        dem = dem.rio.reproject(crs, resampling=rasterio.enums.Resampling.bilinear)\n    return dem\n</code></pre>"},{"location":"api/#nhd-utilities","title":"NHD Utilities","text":""},{"location":"api/#streamkit.nhd.rasterize_nhd","title":"<code>streamkit.nhd.rasterize_nhd(nhd_flowlines, dem)</code>","text":"<p>Create a raster representation of NHD flowlines traced on a DEM.</p> <p>Converts vector NHD flowlines to a raster stream network by identifying channel heads, tracing streams downslope along the DEM's flow directions, and linking stream segments. Small streams (&lt; 2 pixels) are removed and the remaining streams are relabeled with consecutive integers.</p> <p>Parameters:</p> Name Type Description Default <code>nhd_flowlines</code> <code>GeoDataFrame</code> <p>Vector flowline data from the National Hydrography Dataset containing stream geometries.</p> required <code>dem</code> <code>DataArray</code> <p>Digital elevation model raster with spatial reference information. Used to determine flow directions for stream tracing.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>A raster DataArray where each pixel value represents a unique stream ID (0 for non-stream pixels, consecutive positive integers for stream segments).</p> Source code in <code>streamkit/nhd.py</code> <pre><code>def rasterize_nhd(nhd_flowlines: gpd.GeoDataFrame, dem: xr.DataArray) -&gt; xr.DataArray:\n    \"\"\"Create a raster representation of NHD flowlines traced on a DEM.\n\n    Converts vector NHD flowlines to a raster stream network by identifying\n    channel heads, tracing streams downslope along the DEM's flow directions,\n    and linking stream segments. Small streams (&lt; 2 pixels) are removed and\n    the remaining streams are relabeled with consecutive integers.\n\n    Args:\n        nhd_flowlines: Vector flowline data from the National Hydrography Dataset\n            containing stream geometries.\n        dem: Digital elevation model raster with spatial reference information.\n            Used to determine flow directions for stream tracing.\n\n    Returns:\n        A raster DataArray where each pixel value represents a unique stream ID (0 for non-stream pixels, consecutive positive integers for stream segments).\n    \"\"\"\n    channel_heads = _nhd_channel_heads(nhd_flowlines)\n\n    xs, ys = zip(*[(pt.x, pt.y) for pt in channel_heads])\n    inverse = ~dem.rio.transform()\n    indices = [inverse * (x, y) for x, y in zip(xs, ys)]\n    points = [\n        (int(row), int(col)) for col, row in indices\n    ]  # note the order of col, row...\n\n    _, flow_directions, _ = flow_accumulation_workflow(dem)\n\n    stream_raster = trace_streams(points, flow_directions)\n    stream_raster = link_streams(stream_raster, flow_directions)\n\n    # drop any small streams (&lt; 2 pixels)\n    # find all unique stream IDs where the count is &lt; 2\n    unique, counts = np.unique(stream_raster.data, return_counts=True)\n    small_streams = unique[counts &lt; 2]\n    for stream_id in small_streams:\n        stream_raster.data[stream_raster.data == stream_id] = 0\n\n    # re-label streams to be consecutive integers\n    unique, counts = np.unique(stream_raster.data, return_counts=True)\n    new_id = 1\n    for stream_id in unique:\n        if stream_id == 0:\n            continue\n        stream_raster.data[stream_raster.data == stream_id] = new_id\n        new_id += 1\n    return stream_raster\n</code></pre>"},{"location":"data/","title":"Downloading Data","text":"In\u00a0[9]: Copied! <pre>import geopandas as gpd\nimport rioxarray as rxr\nimport matplotlib.pyplot as plt\n\nfrom streamkit import get_huc_data\n</pre> import geopandas as gpd import rioxarray as rxr import matplotlib.pyplot as plt  from streamkit import get_huc_data In\u00a0[7]: Copied! <pre>flowlines, dem = get_huc_data(\"180101020502\", nhd_layer=\"flowline_mr\",\n                              crs=\"EPSG:3310\", dem_resolution=10)\n</pre> flowlines, dem = get_huc_data(\"180101020502\", nhd_layer=\"flowline_mr\",                               crs=\"EPSG:3310\", dem_resolution=10) In\u00a0[11]: Copied! <pre>fig, ax = plt.subplots()\ndem.plot(ax=ax)\nflowlines.plot(ax=ax)\n</pre> fig, ax = plt.subplots() dem.plot(ax=ax) flowlines.plot(ax=ax) Out[11]: <pre>&lt;Axes: title={'center': 'band = 1, spatial_ref = 0'}, xlabel='x coordinate of projection\\n[metre]', ylabel='y coordinate of projection\\n[metre]'&gt;</pre>"},{"location":"network/","title":"Stream Network Analysis","text":"In\u00a0[23]: Copied! <pre>import geopandas as gpd\nimport rioxarray as rxr\nimport matplotlib.pyplot as plt\n\nfrom streamkit import (\n    vectorize_streams,\n    flow_accumulation_workflow,\n    vector_streams_to_networkx,\n    strahler_order,\n    upstream_length,\n    networkx_to_gdf,\n    label_mainstem)\n</pre> import geopandas as gpd import rioxarray as rxr import matplotlib.pyplot as plt  from streamkit import (     vectorize_streams,     flow_accumulation_workflow,     vector_streams_to_networkx,     strahler_order,     upstream_length,     networkx_to_gdf,     label_mainstem) In\u00a0[17]: Copied! <pre>streams = rxr.open_rasterio(\"data/sample_streams.tif\", masked=True).squeeze()\ndem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze()\nconditioned_dem, flow_directions, flow_accumulation = flow_accumulation_workflow(dem)\n</pre> streams = rxr.open_rasterio(\"data/sample_streams.tif\", masked=True).squeeze() dem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze() conditioned_dem, flow_directions, flow_accumulation = flow_accumulation_workflow(dem) In\u00a0[43]: Copied! <pre>streams_vec = vectorize_streams(streams, flow_directions, flow_accumulation)\n</pre> streams_vec = vectorize_streams(streams, flow_directions, flow_accumulation) In\u00a0[19]: Copied! <pre>streams_vec.plot(column='stream_id')\n</pre> streams_vec.plot(column='stream_id') Out[19]: <pre>&lt;Axes: &gt;</pre> In\u00a0[20]: Copied! <pre>graph = vector_streams_to_networkx(streams_vec)\n</pre> graph = vector_streams_to_networkx(streams_vec) In\u00a0[21]: Copied! <pre>graph = strahler_order(graph)\ngraph = upstream_length(graph)\ngraph = label_mainstem(graph)\n</pre> graph = strahler_order(graph) graph = upstream_length(graph) graph = label_mainstem(graph) In\u00a0[26]: Copied! <pre>streams_vec = networkx_to_gdf(graph)\n</pre> streams_vec = networkx_to_gdf(graph) In\u00a0[41]: Copied! <pre>fig, axes = plt.subplots(2, 2, figsize=(12, 12))\nstreams_vec.plot(ax=axes[0, 0], column='strahler')\naxes[0, 0].set_title('Strahler Order')\n\nstreams_vec.plot(ax=axes[0, 1], column='max_upstream_length')\naxes[0, 1].set_title('Max Upstream Length')\n\nstreams_vec.plot(ax=axes[1, 0], column='mainstem')\naxes[1, 0].set_title('Mainstem')\n\naxes[1, 1].axis('off')\n</pre> fig, axes = plt.subplots(2, 2, figsize=(12, 12)) streams_vec.plot(ax=axes[0, 0], column='strahler') axes[0, 0].set_title('Strahler Order')  streams_vec.plot(ax=axes[0, 1], column='max_upstream_length') axes[0, 1].set_title('Max Upstream Length')  streams_vec.plot(ax=axes[1, 0], column='mainstem') axes[1, 0].set_title('Mainstem')  axes[1, 1].axis('off') Out[41]: <pre>(np.float64(0.0), np.float64(1.0), np.float64(0.0), np.float64(1.0))</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"reaches/","title":"Reach Delineation","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport rioxarray as rxr\nimport matplotlib.pyplot as plt\n\nfrom streamkit import delineate_reaches, vectorize_streams, flow_accumulation_workflow\n</pre> import geopandas as gpd import rioxarray as rxr import matplotlib.pyplot as plt  from streamkit import delineate_reaches, vectorize_streams, flow_accumulation_workflow <pre>OMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</pre> In\u00a0[2]: Copied! <pre>dem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze()\nstreams = rxr.open_rasterio(\"data/sample_streams.tif\").squeeze()\n</pre> dem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze() streams = rxr.open_rasterio(\"data/sample_streams.tif\").squeeze() In\u00a0[3]: Copied! <pre>reaches = delineate_reaches(streams, dem, penalty=5, min_length=500, smooth_window=5, threshold_degrees=1)\n</pre> reaches = delineate_reaches(streams, dem, penalty=5, min_length=500, smooth_window=5, threshold_degrees=1) In\u00a0[4]: Copied! <pre>cdem, flow_directions, flow_accumulation = flow_accumulation_workflow(dem)\nvreaches = vectorize_streams(reaches, flow_directions, flow_accumulation)\nvstreams = vectorize_streams(streams, flow_directions, flow_accumulation)\n</pre> cdem, flow_directions, flow_accumulation = flow_accumulation_workflow(dem) vreaches = vectorize_streams(reaches, flow_directions, flow_accumulation) vstreams = vectorize_streams(streams, flow_directions, flow_accumulation) In\u00a0[5]: Copied! <pre>fig, axes = plt.subplots(1,2, figsize=(12,6))\nvstreams['color_idx'] = range(len(vstreams))\nvreaches['color_idx'] = range(len(vreaches))\n\ndem.plot(ax=axes[0], add_colorbar=False)\nvstreams.plot(ax=axes[0], column='color_idx', cmap='tab20', legend=False)\ndem.plot(ax=axes[1], add_colorbar=False)\nvreaches.plot(ax=axes[1], column='color_idx', cmap='tab20', legend=False)\n</pre> fig, axes = plt.subplots(1,2, figsize=(12,6)) vstreams['color_idx'] = range(len(vstreams)) vreaches['color_idx'] = range(len(vreaches))  dem.plot(ax=axes[0], add_colorbar=False) vstreams.plot(ax=axes[0], column='color_idx', cmap='tab20', legend=False) dem.plot(ax=axes[1], add_colorbar=False) vreaches.plot(ax=axes[1], column='color_idx', cmap='tab20', legend=False) Out[5]: <pre>&lt;Axes: title={'center': 'band = 1, spatial_ref = 0'}, xlabel='x', ylabel='y'&gt;</pre>"},{"location":"watershed/","title":"Watershed Functions","text":"In\u00a0[1]: Copied! <pre>import rioxarray as rxr\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\nfrom streamkit import flow_accumulation_workflow, delineate_subbasins\n</pre> import rioxarray as rxr import geopandas as gpd import matplotlib.pyplot as plt  from streamkit import flow_accumulation_workflow, delineate_subbasins <pre>OMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</pre> In\u00a0[2]: Copied! <pre>streams = rxr.open_rasterio(\"data/sample_streams.tif\", masked=True).squeeze()\ndem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze()\n</pre> streams = rxr.open_rasterio(\"data/sample_streams.tif\", masked=True).squeeze() dem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze() In\u00a0[3]: Copied! <pre>conditioned_dem, flow_directions, flow_accumulation = flow_accumulation_workflow(dem)\n</pre> conditioned_dem, flow_directions, flow_accumulation = flow_accumulation_workflow(dem) In\u00a0[4]: Copied! <pre>subbasins = delineate_subbasins(streams, flow_directions, flow_accumulation)\n</pre> subbasins = delineate_subbasins(streams, flow_directions, flow_accumulation) In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots()\nconditioned_dem.plot(ax=ax)\nsubbasins.plot(ax=ax, alpha=0.3)\n</pre> fig, ax = plt.subplots() conditioned_dem.plot(ax=ax) subbasins.plot(ax=ax, alpha=0.3) Out[5]: <pre>&lt;matplotlib.collections.QuadMesh at 0x16384ab10&gt;</pre>"},{"location":"xs/","title":"Cross Sections","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport rioxarray as rxr\nimport matplotlib.pyplot as plt\n\nfrom streamkit import (\n    network_cross_sections, sample_cross_sections)\n</pre> import geopandas as gpd import rioxarray as rxr import matplotlib.pyplot as plt  from streamkit import (     network_cross_sections, sample_cross_sections) <pre>OMP: Info #276: omp_set_nested routine deprecated, please use omp_set_max_active_levels instead.\n</pre> In\u00a0[2]: Copied! <pre>streams = gpd.read_file(\"data/sample_streams_vec.gpkg\")\ndem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze()\n</pre> streams = gpd.read_file(\"data/sample_streams_vec.gpkg\") dem = rxr.open_rasterio(\"data/sample_dem.tif\", masked=True).squeeze() In\u00a0[10]: Copied! <pre>xsections = network_cross_sections(streams.geometry, 100, 1000, smoothed=True)\nfig, ax = plt.subplots(figsize=(10,10))\ndem.plot(ax=ax)\nxsections.plot(ax=ax, color='red')\n</pre> xsections = network_cross_sections(streams.geometry, 100, 1000, smoothed=True) fig, ax = plt.subplots(figsize=(10,10)) dem.plot(ax=ax) xsections.plot(ax=ax, color='red') Out[10]: <pre>&lt;Axes: title={'center': 'band = 1, spatial_ref = 0'}, xlabel='x', ylabel='y'&gt;</pre> In\u00a0[7]: Copied! <pre>elevation_profiles = sample_cross_sections(xsections, 10)\nelevation_profiles\n</pre> elevation_profiles = sample_cross_sections(xsections, 10) elevation_profiles Out[7]: side geometry distance xs_id linestring_id 0 center POINT (-333906.629 346117.375) 0.0 1 0 1 positive POINT (-333896.63 346117.224) 10.0 1 0 2 positive POINT (-333886.632 346117.072) 20.0 1 0 3 positive POINT (-333876.633 346116.92) 30.0 1 0 4 positive POINT (-333866.634 346116.768) 40.0 1 0 ... ... ... ... ... ... 81600 negative POINT (-337712.067 342108.105) -450.0 816 37 81601 negative POINT (-337704.981 342115.161) -460.0 816 37 81602 negative POINT (-337697.895 342122.217) -470.0 816 37 81603 negative POINT (-337690.809 342129.273) -480.0 816 37 81604 negative POINT (-337683.723 342136.329) -490.0 816 37 <p>81605 rows \u00d7 5 columns</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}